

# 03. Application Debugger  #

### **(pre) 시작 전**, 시간이 소요 될 수 있는 다음을 실행 해 둔다 ###
~~~bash
yum install debuginfo-install 
debuginfo-install procps-ng
~~~
### kdump 용 설치 파일 (Kernel dev 관련 패키지)
```bash
yum --enablerepo=base-debuginfo install –y kernel-debuginfo-$(uname -r)
```

# GDB

## 1.GDB (GNU Debugger) 개요 ##
- Strace 는 모니터링 대상의 System call 을 추적한다.
- ltrace는 모니터링 대상이 사용하는 library를 추적한다. 
- GDB는 Debugger이다. Windows의 Visual Studio 및 Eclipse에서의 Debugger mode를 생각하면 된다. 

## 2. Application 구동 원리 ##
- Application 과 연관된 Troubleshooting을 위해서는 Application 구동 원리를 이해 해야 한다.
 - 1) application Process 구동
 - 2) Application Memory에 적재
 - 3) Application 실행 명령어 
 
- process (kernel fork)
- file system (==> ELF, 라이브러리 적재,  code/text section)
- 언제나 유사한 형태의 메모리 유지 (관리가 쉬움 ) ==> 가상메모리 사용 (물리메모리 적재는 산발/복잡)
- micro-processor 명령어 셋 실행 => RIP => code section
- RIP 실행 중에, 점프 ==> 현재상태 저장하고 다른곳으로 ==> Stack
- RIP 실행 중에, memory 생성 ==> heap 생성/적재

### ELF File 
```
$ hexdump /bin/ls
$ readelf -h /bin/ls
$ readelf -l /bin/ls
$ readelf -S /bin/ls
$ xxd /bin/ls
$ objdump -x /bin/ls
$ objdump -d /bin/ls 
```


# **GDB 실습**

## 3. core dump ##
- core file을 남기도록 설정
`ulimit -a`
~~~bash
[root@clu_1 ~]# ulimit -a
core file size          (blocks, -c) 0
data seg size           (kbytes, -d) unlimited
scheduling priority             (-e) 0
file size               (blocks, -f) unlimited
pending signals                 (-i) 7235
max locked memory       (kbytes, -l) 64
max memory size         (kbytes, -m) unlimited
open files                      (-n) 1024
pipe size            (512 bytes, -p) 8
POSIX message queues     (bytes, -q) 819200
real-time priority              (-r) 0
stack size              (kbytes, -s) 8192
cpu time               (seconds, -t) unlimited
max user processes              (-u) 7235
virtual memory          (kbytes, -v) unlimited
file locks                      (-x) unlimited
~~~

`ulimit -c unlimited`
~~~bash
core file size          (blocks, -c) unlimited
~~~

## 필요한 소스 다운로드 및 컴파일

```bash
wget https://raw.githubusercontent.com/windflex-sjlee/linux_troubleshooting/master/src/test_01_normal.c
wget https://raw.githubusercontent.com/windflex-sjlee/linux_troubleshooting/master/src/test_01.c
wget https://raw.githubusercontent.com/windflex-sjlee/linux_troubleshooting/master/src/test_02.c
wget https://raw.githubusercontent.com/windflex-sjlee/linux_troubleshooting/master/src/test_03.c
wget https://raw.githubusercontent.com/windflex-sjlee/linux_troubleshooting/master/src/test_04.py

[root@clu_1 seg]# pwd
/root/seg
[root@clu_1 seg]# ll
total 20
-rw-r--r-- 1 root root 293 Dec 20 20:59 test_01.c
-rw-r--r-- 1 root root  66 Dec 20 20:59 test_01_normal.c
-rw-r--r-- 1 root root 178 Dec 20 20:59 test_02.c
-rw-r--r-- 1 root root 431 Dec 20 20:59 test_03.c
-rw-r--r-- 1 root root  63 Dec 20 20:59 test_04.py
```

### 다운받은 파일들을 미리 컴파일해 둔다.
```bash
gcc -g -o test_01n ./test_01_normal.c
gcc -g -o test_01 ./test_01.c
gcc -g -o test_02 ./test_02.c
gcc -g -o test_03 ./test_03.c
```

## 4. normal file( not seg fault )##
### debugging을 둘러보자... ##


```bash
[root@clu_1 seg]# gdb ./test_01n -q
Reading symbols from /root/seg/test_01n...done.
(gdb)
```
```bash
(gdb) list main
(gdb) b *main
(gdb) run
(gdb) s
(gdb) s
(gdb) bt
(gdb) print i
(gdb) print $RIP
(gdb) disassemble *main
Dump of assembler code for function main:
   0x000000000040052d <+0>:     push   %rbp
   0x000000000040052e <+1>:     mov    %rsp,%rbp
   0x0000000000400531 <+4>:     sub    $0x10,%rsp
=> 0x0000000000400535 <+8>:     movl   $0x0,-0x4(%rbp)
   0x000000000040053c <+15>:    mov    $0x4005e0,%edi
   0x0000000000400541 <+20>:    callq  0x400410 <puts@plt>
   0x0000000000400546 <+25>:    leaveq
   0x0000000000400547 <+26>:    retq
(gdb) info registers
```
> 정상적인 Application으로써, 가장 단순하고, 정상적인 환경에서 화면/기능에 익숙해 져 본다.

- list <함수명> : 함수를 출력해 본다.
- set listsize 20 : list하는 라인수를 20으로 세팅한다
- b *main : main 함수에 breakpoint를 설정한다.
- s : 다음 라인을 실행한다. (??)
- bt (backtrace) : Call Stack을 추적한다. (??)
- disassemble *main : main함수를 disassemble한다. 
- info registers : register값을 출력한다. 


# 6. Seg. Fault  
## Segmentation Fault 
**Segmentation Fault란** 실행파일(Elf등)에서 메모리로 적재(load)되어 실행될 때, Process 간 영역(Segment)를 침범하였거나, 각 영역에 권한(Permission)에 위배되는 명령을 수행하였을 경우 발생한다. 일반적으로 메모리 관리를 잘못하여, Kernel 영역 혹은 실행 권한이 없는 영역으로 Jump가 실행되어 발생하는 것이 대부분이다. 또다른 경우로는, Stack / Heap 등 동적 메모리 영역이 넘쳐서 발생하기도 한다. 

> Hacker는 segmentation falut가 발생하면 만세를 부른다.? 왜 ?!!
> core dump가 남겨지도록 `ulimit`를 설정 했는지 확인할것.

```bash
[root@clu_1 seg]# ./test_01
Segmentation fault (core dumped)
[root@clu_1 seg]# ll core*
-rw------- 1 root root 253952 Dec 20 21:21 core.21000
[root@clu_1 seg]# file core.21000
core.21000: ELF 64-bit LSB core file x86-64, version 1 (SYSV), SVR4-style, from './test_01', real uid: 0, effective uid: 0, real gid: 0, effective gid: 0, execfn: './test_01', platform: 'x86_64'
```

```bash
[root@clu_1 seg]# gdb ./test_01 core.21000 -q
Reading symbols from /root/seg/test_01...done.
[New LWP 21000]
Core was generated by `./test_01'.
Program terminated with signal 11, Segmentation fault.
#0  0x000000000040059f in main (argc=1, argv=0x7fff5864ecc8) at ./test_01.c:17
17        *p = 1;
Missing separate debuginfos, use: debuginfo-install glibc-2.17-222.el7.x86_64
(gdb)
```
> gdb를 실행하면, 초기 메세지에 요약 정보를 출력해 준다. 
> gdb의 **-q**옵션은 quite 를 의미 한다. 초기 prompt message를 최소화 한다.

### gdb 환경에서 아래 명령어 들을 수행해 보자. 
~~~bash
(gdb) list main
(gdb) set listsize 50
(gdb) bt
(gdb) print p
(gdb) disas *main
(gdb) disas /m *main
(gdb) b *main
(gdb) info register   
~~~

```bash
(gdb) bt
#0  0x000000000040059f in main (argc=1, argv=0x7fff5864ecc8) at ./test_01.c:17
(gdb) disass /m *main
    [ 중  략 ]
17        *p = 1;
   0x000000000040059b <+110>:   mov    -0x18(%rbp),%rax
=> 0x000000000040059f <+114>:   movl   $0x1,(%rax)
18
19        return 0;
   0x00000000004005a5 <+120>:   mov    $0x0,%eax
```

# 7. Seg. Fault 예제 
## 좀 더 복잡한 예를 실행 한다. 
> test_03

```bash
[root@clu_1 seg]# ./test_03
*** Error in `./test_03': double free or corruption (fasttop): 0x000000000259d010 ***
```

## 8. strace/ltrace 결과 비교 
- `starce ./test_03`
~~~bash
writev(3, [{"*** Error in `", 14}, {"./test_03", 9}, {"': ", 3}, {"double free or corruption (fastt"..., 35}, {": 0x", 4}, {"00000000011a4010", 16}, {" ***\n", 5}], 7*** Error in `./test_03': double free or corruption (fasttop): 0x00000000011a4010 ***
~~~
> strace를 실행하면, systemcall 의 실행 흐름을 알 수 있다. 그러나, 어디에서 어떤 이유로 에러가 발생했는지 알기 어렵다.

- `ltrace ./test_03`
```bash
[root@clu_1 seg]# ltrace ./test_03
__libc_start_main(0x400688, 1, 0x7ffe2c28cb68, 0x4006c0 <unfinished ...>
malloc(1)                                                                 = 0x2389010
free(0x2389010)  
``` 
> libc 라이브러리에서 malloc, free 함수를 사용한 사실만을 확인해 준다. 


## 9. GDB 실행 with core dump ##

- `gdb ./test_03 core.xxx`

```bash
[root@clu_1 seg]# gdb ./test_03 core.21222 -q
Reading symbols from /root/seg/test_03...done.
[New LWP 21222]
Core was generated by `./test_03'.
Program terminated with signal 6, Aborted.
#0  0x00007fcf9ffa7277 in __GI_raise (sig=sig@entry=6)
    at ../nptl/sysdeps/unix/sysv/linux/raise.c:56
56	  return INLINE_SYSCALL (tgkill, 3, pid, selftid, sig);
Missing separate debuginfos, use: debuginfo-install libgcc-4.8.5-28.el7_5.1.x86_64
```
> 실행하면 에러에 대한 개요 메세지를 볼수 있다. 

- debuginfo가 제대로 설치되지 않으면, 아래와 같은 문구가 보인다. 
```bash
Core was generated by `./test_03'.
Program terminated with signal 6, Aborted.
#0  0x00007fa99d2b0277 in raise () from /lib64/libc.so.6
Missing separate debuginfos, use: debuginfo-install glibc-2.17-222.el7.x86_64 libgcc-4.8.5-28.el7_5.1.x86_64
```

## GDB 명령을 실행해 본다. 특히 **bt**를 눈여겨 본다. 


### **(gdb) bt **

```bash
(gdb) bt
#0  0x00007fcf9ffa7277 in __GI_raise (sig=sig@entry=6)
    at ../nptl/sysdeps/unix/sysv/linux/raise.c:56
#1  0x00007fcf9ffa8968 in __GI_abort () at abort.c:90
#2  0x00007fcf9ffe9d37 in __libc_message (do_abort=do_abort@entry=2, 
    fmt=fmt@entry=0x7fcfa00fbd58 "*** Error in `%s': %s: 0x%s ***\n")
    at ../sysdeps/unix/sysv/linux/libc_fatal.c:196
#3  0x00007fcf9fff2499 in malloc_printerr (ar_ptr=0x7fcfa0337760 <main_arena>, 
    ptr=<optimized out>, str=0x7fcfa00fbe18 "double free or corruption (fasttop)", 
    action=3) at malloc.c:5025
#4  _int_free (av=0x7fcfa0337760 <main_arena>, p=<optimized out>, have_lock=0)
    at malloc.c:3847
#5  0x0000000000400642 in Abnormal () at ./test_03.c:10
#6  0x0000000000400676 in AbnormalContainer () at ./test_03.c:19
#7  0x00000000004006a1 in main (argc=1, argv=0x7ffe48376b18) at ./test_03.c:29
```

> 상기 Call Stack trace는, **main ->AbnormalContainer -> Abnormal -> init_free -> malloc_printerr ->__libc_message ->GI_abort ->GI_raise** 순서로 함수를 실행하다가, GI_raise ==>  0x00007fcf9ffa7277 위치에서 실행 종료 되었다.
>  GI_raise는 메세지를 발생하는 가젯이므로, 직접적인 원인은 malloc_printerr 이며, 원인은 double free / corruption 이다. 또한, 이것을 호출한 함수는 Abnormal() 이다. 

### list Abnormal 을 살펴 보자...!

~~~bash
(gdb) list Abnormal
1	#include <stdio.h> 
2	#include <memory.h>
3	
4	void Abnormal()
5	{
6	    int n = 1024;
7	    char *p = (char *)malloc(sizeof(char) * 1);
8	
9	    free(p);
10	    free(p);                /* double free */
~~~

### disas /m Abnormal
- `(gdb) disas Abnormal` 실행해 보고 난 후에, 소스코드와 함께 보기위한 **/m** 옵션으로 실행해 본다.

~~~bash
(gdb) disas /m Abnormal
Dump of assembler code for function Abnormal:
5	{
   0x000000000040060d <+0>:	push   %rbp
   0x000000000040060e <+1>:	mov    %rsp,%rbp
   0x0000000000400611 <+4>:	sub    $0x20,%rsp
6	    int n = 1024;
   0x0000000000400615 <+8>:	movl   $0x400,-0x4(%rbp)
7	    char *p = (char *)malloc(sizeof(char) * 1);
   0x000000000040061c <+15>:	mov    $0x1,%edi
   0x0000000000400621 <+20>:	callq  0x400510 <malloc@plt>
   0x0000000000400626 <+25>:	mov    %rax,-0x10(%rbp)
8	
9	    free(p);
   0x000000000040062a <+29>:	mov    -0x10(%rbp),%rax
   0x000000000040062e <+33>:	mov    %rax,%rdi
   0x0000000000400631 <+36>:	callq  0x4004c0 <free@plt>
10	    free(p);                /* double free */
   0x0000000000400636 <+41>:	mov    -0x10(%rbp),%rax
   0x000000000040063a <+45>:	mov    %rax,%rdi
   0x000000000040063d <+48>:	callq  0x4004c0 <free@plt>
~~~
> 동일한 대상에 free가 2회 진행됨을 확인 할 수 있다. <free@plt>

### info functions
- 에러 발생 시점에 function들을 살펴 본다. 
~~~bash
(gdb)info functions
File ./test_03.c:
void Abnormal();
void AbnormalContainer();
void Normal();
int main(int, char **);
~~~
> **info functions**는 많은 내부함수를 보여준다. 여기에서는 main, Normal, AbnormalContainer, Abnormal 등 함수만 발췌.


### 1기타 지역변수 확인 
- `(gdb) info local`



# 내부 명령어 디버깅 (free)
## 내부명령어 중 **/bin/free**명령어를 GDB로 확인해 보자

- 내부명령어의 GDB 분석을 위해서는 Source Code가 필요하다. 
- Source Code 없이 분석도 가능하나, ASM 레벨에서 분석을 해야 하므로, 공객된 Source Code와 함께 분석한다. 

~~~bash
$ yum install debuginfo-install 
$ debuginfo-install procps-ng
~~~
> **debuginfo-install**은 미리 다운로드 하도록 가이드 하였다.

## GDB를 통하여 자유롭게 실습한다. 
```bash
gdb /bin/free
(gdb) list

```


# 11. 기존 프로세스에 gdb attach 
## apache daemon에 GDB를 붙여 본다.

### Apache 설치 및 구동확인

~~~bash
ps -ef | grep http

su -
sudo yum install -y httpd
rpm -qa httpd
systemctl start httpd 
systemctl status httpd
~~~
> RPM 명령어 참조 : https://github.com/windflex-sjlee/linux_troubleshooting/blob/master/rpm_cmd_info.md

###  HTTPD 구동 확인 (ps -ef | grep http)

```bash
[root@clu_1 ~]# ps -ef | grep http
root      4125     1  0 19:44 ?        00:00:00 /usr/sbin/httpd -DFOREGROUND
apache    4129  4125  0 19:44 ?        00:00:00 /usr/sbin/httpd -DFOREGROUND
apache    4130  4125  0 19:44 ?        00:00:00 /usr/sbin/httpd -DFOREGROUND
apache    4131  4125  0 19:44 ?        00:00:00 /usr/sbin/httpd -DFOREGROUND
apache    4132  4125  0 19:44 ?        00:00:00 /usr/sbin/httpd -DFOREGROUND
apache    4133  4125  0 19:44 ?        00:00:00 /usr/sbin/httpd -DFOREGROUND
root      4158  3749  0 19:46 pts/0    00:00:00 grep --color=auto http
```
> root 가 실행해준 Apache Daemon process를 잡는다. 
> `gdb /usr/sbin/httpd 4125`  or   `gdb -q -p 4125` (q 옵션 : quite )


~~~bash
(gdb) where
#0  0x00007f34334a4c53 in __select_nocancel ()
    at ../sysdeps/unix/syscall-template.S:81
#1  0x00007f3433bc05a5 in apr_sleep () from /lib64/libapr-1.so.0
#2  0x00007f3434ee5811 in ap_wait_or_timeout ()
#3  0x00007f342aaf50de in prefork_run () from /etc/httpd/modules/mod_mpm_prefork.so
#4  0x00007f3434ee4ffe in ap_run_mpm ()
#5  0x00007f3434eddd76 in main ()
~~~

### 현재 상태 및 실행 위치 확인
- 현재 Apache 서비스는 다음과 같은 순서로 함수를 실행하고 정지 상태이다. (GDB가 Break를 걸고 있다.) 
> main() -> ap_run_mpm() -> prefork_run()  -> ap_wait_or_timeout()  -> apr_sleep()  -> __select_nocancel()

~~~bash
(gdb) bt
(gdb) f 5
(gdb) list
~~~

### 실행 상태에서 core 파일 생성
- 실행 중인 상태에서는 **서비스 운영 등의 목적**으로 인하여 분석하기 어려운 경우가 많다. 따라서 현재 상태를 스냅샷 찍듯이 core파일을 생성하고, core파일을 통해서 상태 분석을 진행한다. 
- 실행중인 프로세스에서 core 파일을 생성해 준다. (이것은 Process의 스냅샷이라고 보면 된다. )
```bash
(gdb) generate-core-file
(gdb) detach
```
> 종료시에는 기존 프로세스와 분리 시켜주어야, 기존 구동중인 프로세스가 안정적으로 재동작 한다. 


```bash
[root@clu_1 ~]# ls -al core*
-rw-r--r-- 1 root root 2443552 Dec  6 20:32 core.4125
-rw------- 1 root root  536576 Dec  6 20:04 core.4428
-rw------- 1 root root  536576 Dec  6 20:23 core.4983

[root@clu_1 ~]# file core.4125 
core.4125: ELF 64-bit LSB core file x86-64, version 1 (SYSV), SVR4-style, from '/usr/sbin/httpd', real uid: 0, effective uid: 0, real gid: 0, effective gid: 0, execfn: '/usr/sbin/httpd', platform: 'x86_64'
```
> 이제, 실제 httpd 서비스가 없어도  core파일 만으로 상태를 분석할 수 있다. 

~~~bash
[root@clu_1 ~]# systemctl stop httpd
[root@clu_1 ~]# gdb -q core.4125 
[New LWP 4125]
Missing separate debuginfo for the main executable file
Try: yum --enablerepo='*debug*' install /usr/lib/debug/.build-id/17/ef80493e25188af719aaf17734957e3754fc07
Core was generated by `/usr/sbin/httpd'.
#0  0x00007f34334a4c53 in ?? ()
"/root/core.4125" is a core file.
Please specify an executable to debug.
~~~




